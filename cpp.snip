include c.snip
# template{{{
snippet stemp
#include<bits/stdc++.h>
    #define ENABLE_DEBUG 1
    // Kana's kitchen {{{
    #include<bits/stdc++.h>
    #define ALL(v) std::begin(v),std::end(v)
    #define LOOP(k) for(i64 ngtkana_is_a_genius=0; ngtkana_is_a_genius<(i64)k; ngtkana_is_a_genius++)

    using i32 = std::int_least32_t;
    using i64 = std::int_least64_t;
    using u32 = std::uint_least32_t;
    using u64 = std::uint_least64_t;
    using usize = std::size_t;

    template <class T, class U> using pair = std::pair<U, T>;
    template <class T> using diag_pair = std::pair<T, T>;
    template <class... Args> using tuple = std::tuple<Args...>;
    template <class T> using vec = std::vector<T>;
    template <class T> using numr = std::numeric_limits<T>;

    #ifdef NGTKANA
    #include<debug.hpp>
    #else
    #define DEBUG(...)(void)0
    #endif
    /*}}}*/

    int main(){
        std::cin.tie(nullptr);
        std::ios::sync_with_stdio(false);
        std::cout << std::setprecision(15) << std::fixed;

        $0
    }
#!#}}}
# short snippets{{{
snippet out
    std::cout << $0 << '\n';

snippet dfsin
    DEBUG("in", ${1});

snippet dfsout
    DEBUG("out", ${1});
#}}}
# meta{{{
snippet mkvec
    template <usize N, class T, class... Args, std::enable_if_t<N==0, int> = 0>
    auto mkvec(Args... args) {
        return T(args...);
    }
    template <usize N, class T, class... Args, std::enable_if_t<N!=0, int> = 0>
    auto mkvec(usize sz, Args... args) {
        using value_type = std::decay_t<decltype(mkvec<N-1, T>(args...))>;
        return vec<value_type>(sz, value_type(args...));
    }
snippet project
    template<std::size_t Idx, class Container, class Value = std::tuple_element_t<Idx, typename Container::value_type>>
        auto project(Container const& container)
    {
        std::vector<Value> ans(container.size());
        std::transform(ALL(container), ans.begin(), [](auto&& tuple){ return std::get<Idx>(tuple);});
        return ans;
    }
snippet span
    template <class Begin, class End>
    struct span {
        using value_type=typename Begin::value_type;

        Begin begin_;
        End end_;

        span(Begin begin__, End end__)
            :begin_(begin__), end_(end__) {}

        template<class T>
        span(T const&v,i64 l,i64 r)
            : span(std::begin(v) + l, std::begin(v) + r) {}

        auto begin() { return begin_; }
        auto end() { return end_; }
        auto begin() const { return begin_; }
        auto end() const { return end_; }
    };
    template <class T>
    auto make_span(T const& v, usize l, usize r) {
        using iterator_type = std::decay_t<decltype(v.begin())>;
        return span<iterator_type, iterator_type>(v, l, r);
    }
!#}}}
# short ones{{{
snippet cmn
    auto cmn = [](auto& x, auto y){ if (x>y) { x=y; return true; } return false; };

snippet cmx
    auto cmx = [](auto& x, auto y){ if (x<y) { x=y; return true; } return false; };

snippet min_fn
    auto min_fn = [](auto x, auto y){ return std::min(x,y); };

snippet max_fn
    auto max_fn = [](auto x, auto y){ return std::max(x,y); };

snippet xor_fn
    auto xor_fn = [](auto x, auto y) { return x ^ y; };

snippet array_add_assign
    // array add-assign{{{
    template <std::size_t N, class T, class U> auto operator+=
        (std::array<T, N> & x, std::array<U, N> const& y)
    {
        for(std::size_t i=0;i<N;i++)x.at(i)+=y.at(i);
    }
    //}}}

snippet array_sub_assign
    template <std::size_t N, class T, class U> auto operator-={{{
        (std::array<T, N> & x, std::array<U, N> const& y)
    {
        for(std::size_t i=0;i<N;i++)x.at(i)-=y.at(i);
    }
    //}}}
#}}}
# mints {{{
snippet mint
    template <class ModType> struct modint {
        using value_type = typename ModType::value_type;
        using mint = modint<ModType>;
        using mod_type = ModType;

        static value_type mod() { return ModType::value; }

    private:
        static value_type inverse(value_type x) {
            value_type y=1,u=mod(),v=0;
            while(x){
                value_type q=u/x;
                u-=q*x; std::swap(x,u);
                v-=q*y; std::swap(y,v);
            }
            assert(x==0 && std::abs(y)==mod() && std::abs(u)==1 && std::abs(v)<mod());
            return v<0?v+mod():v;
        }

    public:
        // the member variable
        value_type value;

        // constructors
        modint()=default;
        modint(modint const&)=default;
        modint(modint&&)=default;
        modint& operator=(modint const&)=default;
        modint& operator=(modint&&)=default;
        ~modint()=default;

        template <class T> modint(T t) : value([t] () mutable {
                if ( t <= -static_cast<T>(mod()) || static_cast<T>(mod()) <= t ) t %= mod();
                return t < 0 ? t + mod() : t;
                }()) {}

        // operators
        mint& operator+= (mint y) {
            value += y.value;
            if (mod() <= value) value -= mod();
            return *this;
        }

        mint& operator-= (mint y) {
            value -= y.value;
            if ( value < 0 ) value += mod();
            return *this;
        }

        mint& operator*= (mint y) {
            value = (long long)value * y.value % mod();
            return *this;
        }

        mint& operator/= (mint y) {
            value = (long long)value * inverse(y.value) % mod();
            return *this;
        }

        mint& operator++() { return *this+=1; }
        mint& operator--() { return *this-=1; }
        mint  operator++(int) { mint this_=*this; ++*this; return this_; }
        mint  operator--(int) { mint this_=*this; --*this; return this_; }

        // static member functions
        static mint inv(mint x) { return inverse(x.value); }

        static mint m1pow(long long y) { return y%2?-1:1; }

        static mint pow(mint x, unsigned long long y) {
            mint ans=1;
            for(;y;y>>=1){
                if(y&1ull) ans*=x;
                x*=x;
            }
            return ans;
        }

        // non-member functions
        mint& add_assign(mint y) { return *this+=y; }
        mint& sub_assign(mint y) { return *this-=y; }
        mint& mul_assign(mint y) { return *this*=y; }
        mint& div_assign(mint y) { return *this/=y; }
        mint& inv_assign()       { return *this = inv(*this); }
        mint& pow_assign(unsigned long long y){ return *this = pow(*this, y); }

        mint add(mint y) { mint ans=*this; return ans.add_assign(y); }
        mint sub(mint y) { mint ans=*this; return ans.sub_assign(y); }
        mint mul(mint y) { mint ans=*this; return ans.mul_assign(y); }
        mint div(mint y) { mint ans=*this; return ans.div_assign(y); }
        mint inv()       { mint ans=*this; return ans.inv_assign(); }
        mint pow(unsigned long long y) { return pow(*this, y); }
        mint square(mint x) { return *this * *this; }
        mint cube(mint x) { return *this * *this * *this; }

        template <class F> mint map(F const& f){
            value=f(value);
            return *this;
        }
    };

    template <class T> std::istream&
    operator>>(std::istream& is, modint<T>& x) {
        typename modint<T>::value_type y;
        is >> y;
        x = modint<T>{ y };
        return is;
    }
    template <class T> std::ostream&
    operator<<(std::ostream& os, modint<T> x) {
        return os << x.value;
    }

    template <class T> modint<T> operator+(modint<T> x, modint<T> y) { return x+=y; }
    template <class T> modint<T> operator-(modint<T> x, modint<T> y) { return x-=y; }
    template <class T> modint<T> operator*(modint<T> x, modint<T> y) { return x*=y; }
    template <class T> modint<T> operator/(modint<T> x, modint<T> y) { return x/=y; }
    template <class T> bool operator==(modint<T> x, modint<T> y) { return x.value==y.value; }
    template <class T> bool operator!=(modint<T> x, modint<T> y) { return x.value!=y.value; }

    template <class T, class U> modint<T> operator+(modint<T> x, U y) { return x+modint<T>(y); }
    template <class T, class U> modint<T> operator-(modint<T> x, U y) { return x-modint<T>(y); }
    template <class T, class U> modint<T> operator*(modint<T> x, U y) { return x*modint<T>(y); }
    template <class T, class U> modint<T> operator/(modint<T> x, U y) { return x/modint<T>(y); }
    template <class T, class U> bool operator==(modint<T> x, U y) { return x==modint<T>(y); }
    template <class T, class U> bool operator!=(modint<T> x, U y) { return x!=modint<T>(y); }

    template <class T, class U> modint<T> operator+(U x, modint<T> y) { return modint<T>(x)+y; }
    template <class T, class U> modint<T> operator-(U x, modint<T> y) { return modint<T>(x)-y; }
    template <class T, class U> modint<T> operator*(U x, modint<T> y) { return modint<T>(x)*y; }
    template <class T, class U> modint<T> operator/(U x, modint<T> y) { return modint<T>(x)/y; }
    template <class T, class U> bool operator==(U x, modint<T> y) { return modint<T>(x)==y; }
    template <class T, class U> bool operator!=(U x, modint<T> y) { return modint<T>(x)!=y; }

snippet fact
    struct factorials {
        std::vector<mint> fact, finv;

        factorials(usize n)
            : fact(n, 1), finv(n)
        {
            for(usize i=1;i<n;i++){
                fact.at(i) = fact.at(i-1) * i;
            }

            finv.at(n-1) = fact.at(n-1).inv();
            for(usize i=n-1; i; i--){
                finv.at(i-1) = finv.at(i) * i;
            }
        }
        std::size_t size() const { return fact.size(); }
        std::size_t max() const { return fact.size() - 1; }
        mint at(std::size_t i) const { return fact.at(i); }
        mint inv(std::size_t i) const { return finv.at(i); }

        template <class T, class U, std::enable_if_t< std::is_integral<T>::value && std::is_integral<U>::value, int> = 0>
        mint binom(T n, U k) {
            assert(0<=n);
            if (k<0||n<k) return 0;
            assert(k<=n && static_cast<usize>(n)<size());
            return fact.at(n) * finv.at(k) * finv.at(n-k);
        }

        template <class T, class U, std::enable_if_t< std::is_integral<T>::value && std::is_integral<U>::value, int> = 0>
        mint deal(T n, U k) {
            if (n==0 && k==0) return 1;
            return binom(n+k-1, k-1);
        }
    };

snippet moly
    using poly_t=std::vector<mint>;
    namespace moly_utils {
        static poly_t mod, qd, qinv;
        static i64 deg;
        static void generate(poly_t v){
            mod=([&v]{while(!v.empty()&&v.back()==0)v.pop_back();return v;}());
            qd=mod;mint t=1/qd.back();qd.pop_back();for(mint&x:qd)x*=-t;
            qinv=mod;qinv.erase(qinv.begin());for(mint&x:qinv)x=-x;
            deg=v.size()-1;
            assert(deg);
        }
        static poly_t&normalize(poly_t&a){
            for(;deg<(i64)a.size();a.pop_back()){
                for(i64 i=0;i<deg;i++){
                    a.at(a.size()-1-deg+i)+=a.back()*qd.at(i);
                }
            }
            return a;
        }
    }
    struct moly{
        poly_t value;
        moly()=default;
        moly(poly_t v):value(moly_utils::normalize(v)){}
        moly(std::initializer_list<mint>il):value(il){}
        mint const&at(std::size_t i)const&{return value.at(i);}
        mint&at(std::size_t i)&{return value.at(i);}
        std::size_t size()const&{return value.size();}
        static moly qd(){return moly_utils::qd;}
        static moly qinv(){return moly_utils::qinv;}
    };
    std::ostream&operator<<(std::ostream&os,moly const&a){return os<<a.value;}
    moly operator*(moly a, moly b){
        i64 l=a.size(),m=b.size();
        poly_t c(l+m-1);
        for(i64 i=0;i<l;i++)for(i64 j=0;j<m;j++)c.at(i+j)+=a.at(i)*b.at(j);
        return moly_utils::normalize(c);
    }
    moly&operator*=(moly&a,moly b){return a=a*b;}
    moly pow(moly a, i64 b){moly ans{1};for(;b;b>>=1){if(b&1)ans*=a;a*=a;}return ans;}

# ! }}}
# plint{{{
snippet plint
    struct plint {/*{{{*/
        i64 value;
        plint()=default;
        plint(i64 x):value(x){}
        bool is_inf()const{return value==numr<i64>::max();}
        static plint inf(){return numr<i64>::max();}
    };
    bool operator==(plint x, plint y){return x.value==y.value;}
    bool operator!=(plint x, plint y){return !(x==y);}
    bool operator<(plint x, plint y){return x.value<y.value;}
    bool operator>(plint x, plint y){return x.value>y.value;}
    bool operator<=(plint x, plint y){return x.value<=y.value;}
    bool operator>=(plint x, plint y){return x.value>=y.value;}
    plint operator+(plint x, plint y){return x.is_inf()||y.is_inf()||(0ll<=x&&0ll<=y)&&plint::inf().value-x.value<=y.value?plint::inf():x.value+y.value;};
    plint operator-(plint x){assert(!x.is_inf());return -x.value;};
    plint operator-(plint x,plint y){return x+(-y);};
    std::ostream&operator<<(std::ostream&os,plint x){return os<<(x.is_inf()?"_":std::to_string(x.value));}/*}}}*/
# !plint}}}
snippet union_find
    // Union-Find Tree {{{
    class union_find {
        std::vector<int> p;

    public:
        union_find()=default;
        union_find(union_find const&)=default;
        union_find(union_find&&)=default;
        union_find& operator=(union_find const&)=default;
        union_find& operator=(union_find&&)=default;
        ~union_find()=default;

        union_find(int n)
            : p(n, -1) {}

        auto get_internal_table() const { return p; }

        bool is_root(int i) const { return p.at(i) < 0; }

        int root(int i) { return is_root(i) ? i : p.at(i) = root(p.at(i)); }

        int size(int i) { return -p.at(root(i)); }

        bool unite(int i, int j) {
            i = root(i);
            j = root(j);
            if (i==j) return false;
            if (size(i) > size(j)) std::swap(i, j);

            p.at(j) += p.at(i);
            p.at(i) = j;
            return true;
        }
    };
    // }}}
#}}}
# monoids{{{
snippet add_monoid
    template <class Value> struct add_monoid_t {
      using value_type = Value;
      static value_type op(value_type l, value_type r) { return l + r; }
      static const value_type id() { return 0; }
    };

snippet min_monoid
    template <class Value> struct min_monoid_t {
        using value_type = Value;
        static value_type op(value_type l, value_type r) { return std::min(l, r); }
        static const value_type id() { return std::numeric_limits<Value>::max(); }
    };

snippet max_monoid
    template <class Value> struct max_monoid_t {
        using value_type = Value;
        static value_type op(value_type l, value_type r) { return std::max(l, r); }
        static const value_type id() { return std::numeric_limits<Value>:min(); }
    };

snippet minmax_monoid
    template <class MinValue, class MaxValue> struct minmax_node_t {
        MinValue min;
        MaxValue max;

        minmax_node_t(MinValue min_, MaxValue max_) : min(min_), max(max_) {}

        operator std::pair<MinValue, MaxValue>() { return std::pair(min, max); }
    };

    template <class MinValue, class MaxValue>
    minmax_node_t (MinValue min, MaxValue max) -> minmax_node_t<MinValue, MaxValue>;

    template <class MinValue, class MaxValue> std::ostream& operator<<
        (std::ostream& os, minmax_node_t<MinValue, MaxValue> const& node)
    {
        return os<<'['<<node.min<<','<<node.max<<']';
    }

    template <class MinValue, class MaxValue> struct minmax_monoid_t {
        using value_type = minmax_node_t<MinValue, MaxValue>;
        static value_type op(value_type l, value_type r) { return value_type(std::min(l.min, r.min), std::max(l.max, r.max)); }
        static const value_type id() {
            return minmax_node_t<MaxValue, MaxValue>(
                std::numeric_limits<MinValue>::max(),
                std::numeric_limits<MaxValue>::min()
            );
        }
    };
#}}}
